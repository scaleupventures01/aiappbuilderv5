<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VirtualizedMessageList Performance Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .test-header {
            background: #2563eb;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .test-controls {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .test-controls button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            font-weight: 500;
        }
        .test-controls button:hover {
            background: #2563eb;
        }
        .test-controls button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            padding: 20px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #e5e7eb;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #1f2937;
        }
        .metric-label {
            font-size: 12px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .metric-good { color: #10b981; }
        .metric-warning { color: #f59e0b; }
        .metric-bad { color: #ef4444; }
        .chat-container {
            height: 400px;
            border: 1px solid #e5e7eb;
            margin: 20px;
            border-radius: 5px;
            position: relative;
        }
        .test-log {
            max-height: 200px;
            overflow-y: auto;
            padding: 15px;
            background: #f9fafb;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        .log-info { color: #3b82f6; }
        .log-success { color: #10b981; }
        .log-warning { color: #f59e0b; }
        .log-error { color: #ef4444; }
        
        /* Simplified message bubble styles */
        .message-bubble {
            margin: 10px;
            padding: 12px 16px;
            border-radius: 18px;
            max-width: 70%;
            word-wrap: break-word;
            position: relative;
        }
        .message-user {
            background: #3b82f6;
            color: white;
            margin-left: auto;
            margin-right: 10px;
        }
        .message-ai {
            background: #e5e7eb;
            color: #1f2937;
            margin-right: auto;
            margin-left: 10px;
        }
        .message-system {
            background: #fef3c7;
            color: #92400e;
            margin: 10px auto;
            text-align: center;
            border-radius: 10px;
        }
        .virtual-scroll-container {
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
        }
        .virtual-content {
            position: relative;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>VirtualizedMessageList Performance Test</h1>
            <p>Real-world performance validation for PRD-1.1.4.2</p>
        </div>
        
        <div class="test-controls">
            <button id="test-small" onclick="runTest(100)">Test 100 Messages</button>
            <button id="test-medium" onclick="runTest(1000)">Test 1,000 Messages</button>
            <button id="test-large" onclick="runTest(10000)">Test 10,000 Messages</button>
            <button id="test-extreme" onclick="runTest(50000)">Test 50,000 Messages</button>
            <button id="stress-test" onclick="runStressTest()">Stress Test</button>
            <button id="clear-test" onclick="clearTest()">Clear</button>
            <span style="margin-left: auto;">
                <label>
                    <input type="checkbox" id="enable-virtual" checked> Virtual Scrolling
                </label>
                <label style="margin-left: 15px;">
                    <input type="checkbox" id="enable-dynamic" checked> Dynamic Heights
                </label>
            </span>
        </div>
        
        <div class="metrics-panel">
            <div class="metric-card">
                <div class="metric-value" id="fps-value">--</div>
                <div class="metric-label">FPS</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="memory-value">--</div>
                <div class="metric-label">Memory (MB)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="messages-value">--</div>
                <div class="metric-label">Messages</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="rendered-value">--</div>
                <div class="metric-label">Rendered</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="render-time-value">--</div>
                <div class="metric-label">Render Time (ms)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="jank-value">--</div>
                <div class="metric-label">Jank Events</div>
            </div>
        </div>
        
        <div class="chat-container" id="chat-container">
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">
                Click a test button to start performance testing
            </div>
        </div>
        
        <div class="test-log" id="test-log">
            <div class="log-entry log-info">Ready for testing. Click a button above to start.</div>
        </div>
    </div>

    <script type="text/babel">
        // Performance monitoring
        let performanceMonitor = null;
        let testStartTime = 0;
        let frameCount = 0;
        let lastFrameTime = 0;
        let jankCount = 0;

        // Test data generation
        function generateMessage(id, type = 'user') {
            const types = ['user', 'ai', 'system'];
            const actualType = type === 'random' ? types[Math.floor(Math.random() * types.length)] : type;
            
            const contents = {
                user: [
                    "How do I manage my emotions during volatile trading sessions?",
                    "What's the best strategy for day trading?", 
                    "I'm feeling anxious about my recent losses. Any advice?",
                    "Should I hold or sell this position?",
                    "Can you explain market psychology?",
                ],
                ai: [
                    "Managing emotions during volatile trading requires developing a systematic approach. First, establish clear rules for entry and exit points before you trade...",
                    "Day trading success depends on several key factors: risk management, technical analysis, and psychological discipline. Let me break this down for you...",
                    "It's completely normal to feel anxious after losses. This is actually a sign that you care about your trading, which can be channeled positively...",
                    "To help you make the best decision about your position, I need to understand your risk tolerance and trading strategy. Can you tell me more about...",
                    "Market psychology plays a crucial role in price movements. Understanding mass psychology can give you an edge in trading decisions...",
                ],
                system: [
                    "Trading session started",
                    "Market data updated", 
                    "Risk alert triggered",
                    "Position closed automatically",
                    "Daily summary generated"
                ]
            };
            
            const contentArray = contents[actualType];
            const content = contentArray[Math.floor(Math.random() * contentArray.length)];
            
            return {
                id: `msg-${id}`,
                content: actualType === 'ai' ? content + ` (Message ${id})` : content,
                type: actualType,
                userId: actualType === 'user' ? 'user1' : 'ai',
                createdAt: new Date(Date.now() - (10000 - id) * 30000).toISOString(),
                metadata: {
                    confidence: actualType === 'ai' ? Math.random() : undefined,
                    category: ['trading', 'psychology', 'analysis'][Math.floor(Math.random() * 3)]
                }
            };
        }

        // Simple virtual scrolling implementation
        class VirtualizedMessageList extends React.Component {
            constructor(props) {
                super(props);
                this.state = {
                    scrollTop: 0,
                    isAtBottom: true,
                    renderCount: 0
                };
                this.scrollElementRef = React.createRef();
                this.containerHeight = 400;
                this.itemHeight = 80;
                this.bufferSize = 5;
            }

            componentDidMount() {
                this.startPerformanceMonitoring();
            }

            componentWillUnmount() {
                this.stopPerformanceMonitoring();
            }

            componentDidUpdate(prevProps) {
                if (prevProps.messages.length !== this.props.messages.length) {
                    this.updateMetrics();
                }
            }

            startPerformanceMonitoring() {
                frameCount = 0;
                lastFrameTime = performance.now();
                jankCount = 0;
                
                const monitor = () => {
                    frameCount++;
                    const currentTime = performance.now();
                    const frameTime = currentTime - lastFrameTime;
                    
                    if (frameTime > 16.67) { // > 60fps
                        jankCount++;
                    }
                    
                    lastFrameTime = currentTime;
                    
                    if (frameCount % 60 === 0) { // Update every 60 frames
                        this.updatePerformanceMetrics();
                    }
                    
                    performanceMonitor = requestAnimationFrame(monitor);
                };
                
                performanceMonitor = requestAnimationFrame(monitor);
            }

            stopPerformanceMonitoring() {
                if (performanceMonitor) {
                    cancelAnimationFrame(performanceMonitor);
                    performanceMonitor = null;
                }
            }

            updatePerformanceMetrics() {
                const currentTime = performance.now();
                const timeElapsed = currentTime - (testStartTime || currentTime);
                const fps = Math.round(frameCount * 1000 / Math.max(timeElapsed, 1));
                
                document.getElementById('fps-value').textContent = fps;
                document.getElementById('fps-value').className = `metric-value ${fps >= 55 ? 'metric-good' : fps >= 30 ? 'metric-warning' : 'metric-bad'}`;
                
                document.getElementById('jank-value').textContent = jankCount;
                document.getElementById('jank-value').className = `metric-value ${jankCount === 0 ? 'metric-good' : jankCount < 10 ? 'metric-warning' : 'metric-bad'}`;
                
                if (performance.memory) {
                    const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    document.getElementById('memory-value').textContent = memoryMB;
                    document.getElementById('memory-value').className = `metric-value ${memoryMB < 50 ? 'metric-good' : memoryMB < 100 ? 'metric-warning' : 'metric-bad'}`;
                }
            }

            updateMetrics() {
                const { messages } = this.props;
                const { scrollTop } = this.state;
                const useVirtual = document.getElementById('enable-virtual').checked;
                
                document.getElementById('messages-value').textContent = messages.length;
                
                if (useVirtual) {
                    const viewportHeight = this.containerHeight;
                    const startIndex = Math.max(0, Math.floor(scrollTop / this.itemHeight) - this.bufferSize);
                    const endIndex = Math.min(messages.length, Math.ceil((scrollTop + viewportHeight) / this.itemHeight) + this.bufferSize);
                    const rendered = endIndex - startIndex;
                    
                    document.getElementById('rendered-value').textContent = rendered;
                    document.getElementById('rendered-value').className = `metric-value ${rendered < 50 ? 'metric-good' : rendered < 100 ? 'metric-warning' : 'metric-bad'}`;
                } else {
                    document.getElementById('rendered-value').textContent = messages.length;
                    document.getElementById('rendered-value').className = `metric-value ${messages.length < 100 ? 'metric-good' : messages.length < 1000 ? 'metric-warning' : 'metric-bad'}`;
                }
            }

            handleScroll = () => {
                if (!this.scrollElementRef.current) return;
                
                const element = this.scrollElementRef.current;
                const newScrollTop = element.scrollTop;
                const scrollHeight = element.scrollHeight;
                const clientHeight = element.clientHeight;
                
                this.setState({
                    scrollTop: newScrollTop,
                    isAtBottom: scrollHeight - newScrollTop - clientHeight <= 50
                });
            }

            render() {
                const { messages } = this.props;
                const { scrollTop } = this.state;
                const useVirtual = document.getElementById('enable-virtual')?.checked ?? true;
                const useDynamic = document.getElementById('enable-dynamic')?.checked ?? true;
                
                if (!useVirtual) {
                    return (
                        <div 
                            ref={this.scrollElementRef}
                            className="virtual-scroll-container"
                            onScroll={this.handleScroll}
                        >
                            {messages.map(message => (
                                <MessageBubble key={message.id} message={message} />
                            ))}
                        </div>
                    );
                }

                // Virtual scrolling logic
                const viewportHeight = this.containerHeight;
                const itemHeight = useDynamic ? this.getMessageHeight : () => this.itemHeight;
                const startIndex = Math.max(0, Math.floor(scrollTop / this.itemHeight) - this.bufferSize);
                const endIndex = Math.min(messages.length, Math.ceil((scrollTop + viewportHeight) / this.itemHeight) + this.bufferSize);
                const visibleMessages = messages.slice(startIndex, endIndex);
                const totalHeight = messages.length * this.itemHeight;
                const offsetY = startIndex * this.itemHeight;

                return (
                    <div 
                        ref={this.scrollElementRef}
                        className="virtual-scroll-container"
                        onScroll={this.handleScroll}
                    >
                        <div className="virtual-content" style={{ height: totalHeight }}>
                            <div style={{ transform: `translateY(${offsetY}px)` }}>
                                {visibleMessages.map(message => (
                                    <MessageBubble key={message.id} message={message} />
                                ))}
                            </div>
                        </div>
                    </div>
                );
            }

            getMessageHeight = (message) => {
                // Simple dynamic height calculation
                const baseHeight = 60;
                const contentLength = message.content.length;
                const lineHeight = 20;
                const charsPerLine = 60;
                const lines = Math.max(1, Math.ceil(contentLength / charsPerLine));
                return baseHeight + (lines * lineHeight);
            }
        }

        function MessageBubble({ message }) {
            const className = `message-bubble message-${message.type}`;
            
            return (
                <div className={className}>
                    <div>{message.content}</div>
                    {message.metadata?.confidence && (
                        <div style={{ fontSize: '11px', opacity: 0.7, marginTop: '5px' }}>
                            Confidence: {Math.round(message.metadata.confidence * 100)}%
                        </div>
                    )}
                </div>
            );
        }

        // Test functions
        function runTest(messageCount) {
            const startTime = performance.now();
            testStartTime = startTime;
            frameCount = 0;
            jankCount = 0;
            
            log(`Starting test with ${messageCount} messages...`, 'info');
            
            // Disable buttons during test
            document.querySelectorAll('.test-controls button').forEach(btn => btn.disabled = true);
            
            const messages = [];
            for (let i = 0; i < messageCount; i++) {
                messages.push(generateMessage(i, i % 3 === 0 ? 'user' : i % 3 === 1 ? 'ai' : 'system'));
            }
            
            const renderStartTime = performance.now();
            
            ReactDOM.render(
                React.createElement(VirtualizedMessageList, { messages }),
                document.getElementById('chat-container'),
                () => {
                    const renderTime = performance.now() - renderStartTime;
                    document.getElementById('render-time-value').textContent = Math.round(renderTime);
                    document.getElementById('render-time-value').className = `metric-value ${renderTime < 100 ? 'metric-good' : renderTime < 500 ? 'metric-warning' : 'metric-bad'}`;
                    
                    log(`Test completed in ${Math.round(renderTime)}ms`, 'success');
                    log(`Generated ${messageCount} messages`, 'info');
                    
                    // Re-enable buttons
                    setTimeout(() => {
                        document.querySelectorAll('.test-controls button').forEach(btn => btn.disabled = false);
                    }, 1000);
                }
            );
        }

        async function runStressTest() {
            log('Starting stress test...', 'info');
            
            const testSizes = [100, 500, 1000, 5000, 10000];
            
            for (const size of testSizes) {
                log(`Testing ${size} messages...`, 'info');
                await new Promise(resolve => {
                    runTest(size);
                    setTimeout(resolve, 2000);
                });
            }
            
            log('Stress test completed!', 'success');
        }

        function clearTest() {
            document.getElementById('chat-container').innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">
                    Click a test button to start performance testing
                </div>
            `;
            
            // Reset metrics
            ['fps-value', 'memory-value', 'messages-value', 'rendered-value', 'render-time-value', 'jank-value'].forEach(id => {
                const element = document.getElementById(id);
                element.textContent = '--';
                element.className = 'metric-value';
            });
            
            if (performanceMonitor) {
                cancelAnimationFrame(performanceMonitor);
                performanceMonitor = null;
            }
            
            log('Test cleared', 'info');
        }

        function log(message, type = 'info') {
            const logElement = document.getElementById('test-log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            log('Performance test environment ready', 'success');
            log('Click test buttons to validate VirtualizedMessageList performance', 'info');
        });
    </script>
</body>
</html>