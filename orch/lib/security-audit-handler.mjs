#!/usr/bin/env node

/**
 * Security Audit Handler for ORCH System
 * Ensures all security audits are properly created and stored in /app/PRDs/SecurityAuditReports/
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SECURITY_AUDIT_DIR = path.resolve(__dirname, '../../app/PRDs/SecurityAuditReports');

/**
 * Ensures the security audit directory exists
 */
async function ensureSecurityAuditDirectory() {
  try {
    await fs.mkdir(SECURITY_AUDIT_DIR, { recursive: true });
    console.log(`‚úÖ Security audit directory ensured at: ${SECURITY_AUDIT_DIR}`);
  } catch (error) {
    console.error(`‚ùå Error creating security audit directory: ${error.message}`);
    throw error;
  }
}

/**
 * Generates the security audit filename based on PRD ID
 */
function generateSecurityAuditFilename(prdId) {
  // Ensure consistent naming: PRD-{id}-security-audit.md
  const cleanId = prdId.replace(/^PRD-/, '').replace(/\.md$/, '');
  return `PRD-${cleanId}-security-audit.md`;
}

/**
 * Creates a security audit report
 */
async function createSecurityAudit(prdId, auditContent) {
  await ensureSecurityAuditDirectory();
  
  const filename = generateSecurityAuditFilename(prdId);
  const filepath = path.join(SECURITY_AUDIT_DIR, filename);
  
  try {
    await fs.writeFile(filepath, auditContent, 'utf8');
    console.log(`‚úÖ Security audit created: ${filepath}`);
    return filepath;
  } catch (error) {
    console.error(`‚ùå Error creating security audit: ${error.message}`);
    throw error;
  }
}

/**
 * Checks if a security audit exists for a given PRD
 */
async function securityAuditExists(prdId) {
  const filename = generateSecurityAuditFilename(prdId);
  const filepath = path.join(SECURITY_AUDIT_DIR, filename);
  
  try {
    await fs.access(filepath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Lists all security audits
 */
async function listSecurityAudits() {
  await ensureSecurityAuditDirectory();
  
  try {
    const files = await fs.readdir(SECURITY_AUDIT_DIR);
    const audits = files.filter(f => f.endsWith('-security-audit.md'));
    return audits;
  } catch (error) {
    console.error(`‚ùå Error listing security audits: ${error.message}`);
    return [];
  }
}

/**
 * Security audit template
 */
const SECURITY_AUDIT_TEMPLATE = `# Security Audit Report: {PRD_ID}

**Date**: {DATE}
**Auditor**: Security Architecture Team
**Status**: {STATUS}

## Executive Summary
{SUMMARY}

## Security Assessment

### 1. Authentication & Authorization
- **Status**: {AUTH_STATUS}
- **Findings**: {AUTH_FINDINGS}

### 2. Data Protection
- **Status**: {DATA_STATUS}
- **Findings**: {DATA_FINDINGS}

### 3. Input Validation
- **Status**: {INPUT_STATUS}
- **Findings**: {INPUT_FINDINGS}

### 4. SQL Injection Prevention
- **Status**: {SQL_STATUS}
- **Findings**: {SQL_FINDINGS}

### 5. XSS Prevention
- **Status**: {XSS_STATUS}
- **Findings**: {XSS_FINDINGS}

## Vulnerability Analysis
{VULNERABILITIES}

## Compliance Verification
- [ ] OWASP Top 10 2021
- [ ] GDPR Requirements
- [ ] CCPA Requirements
- [ ] SOC2 Type II
- [ ] ISO 27001

## Risk Assessment
**Overall Risk Level**: {RISK_LEVEL}

{RISK_DETAILS}

## Recommendations
{RECOMMENDATIONS}

## Sign-off
- [ ] Security Architect
- [ ] CISO
- [ ] Technical Lead
- [ ] Product Owner

---
Generated by ORCH Security Audit System
`;

/**
 * Generates a security audit from template
 */
function generateAuditFromTemplate(prdId, data = {}) {
  let audit = SECURITY_AUDIT_TEMPLATE;
  
  // Replace placeholders
  audit = audit.replace('{PRD_ID}', prdId);
  audit = audit.replace('{DATE}', new Date().toISOString().split('T')[0]);
  
  // Replace other placeholders with provided data or defaults
  Object.keys(data).forEach(key => {
    const placeholder = `{${key.toUpperCase()}}`;
    audit = audit.replace(new RegExp(placeholder, 'g'), data[key] || 'Pending Review');
  });
  
  // Replace any remaining placeholders with default text
  audit = audit.replace(/\{[^}]+\}/g, 'Pending Review');
  
  return audit;
}

// Export functions for use in other modules
export {
  ensureSecurityAuditDirectory,
  createSecurityAudit,
  securityAuditExists,
  listSecurityAudits,
  generateSecurityAuditFilename,
  generateAuditFromTemplate
};

// CLI interface
if (import.meta.url === `file://${process.argv[1]}`) {
  const command = process.argv[2];
  
  switch(command) {
    case 'init':
      await ensureSecurityAuditDirectory();
      break;
    
    case 'list':
      const audits = await listSecurityAudits();
      console.log('üìã Security Audits:');
      audits.forEach(audit => console.log(`  - ${audit}`));
      break;
    
    case 'check':
      const prdId = process.argv[3];
      if (prdId) {
        const exists = await securityAuditExists(prdId);
        console.log(`Security audit for ${prdId}: ${exists ? '‚úÖ Exists' : '‚ùå Not found'}`);
      } else {
        console.log('Usage: security-audit-handler.mjs check <PRD_ID>');
      }
      break;
    
    default:
      console.log(`
üîí Security Audit Handler

Commands:
  init              - Ensure security audit directory exists
  list              - List all security audits
  check <PRD_ID>    - Check if audit exists for PRD

Directory: ${SECURITY_AUDIT_DIR}
      `);
  }
}